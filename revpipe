#!/bin/bash
# revpipe: test on a cron, and reconnect reverse ssh tunnel as required.
# author: christopher.r.barry-at-gmaildotcom
# Copyright 2012

#-------------------------------------------------------------------------------
#                         C O N F I G U R A T I O N
#-------------------------------------------------------------------------------
# Your home's external ip address, or DNS name if you have one. Having a dns
# name rather than just an IP here gives you a LOT more flexibility. Get one.
HOME_ADDR=my.homepc.com

# The port on your box at home to connect back to work through.
# This default is likely fine to use.
PORT=2222
export PORT

# max number of tries verifying the remote host per cron cycle
MAXTRIES=5

# That's it.

# modify these if required / desired
PUBLIC_DNS_SERVERS=( 208.67.222.220 8.8.8.8 156.154.70.1 198.153.192.1 4.2.2.1 )

#-------------------------------------------------------------------------------
#                           D E B U G G I N G
# uncomment SSH_DEBUG below to log and help diagnose ssh connection issues.
# connection info written to /var/log/revpipe.stderr by default.
#SSH_DEBUG='-vv'
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#                        P R O G R A M   B E G I N S
#-------------------------------------------------------------------------------
SCRIPT=${0##*/}
LOG=/var/log/${SCRIPT}.log
STDERR=/var/log/${SCRIPT}.stderr
[[ "${SSH_DEBUG}" ]] && {
    STDOUT=/var/log/${SCRIPT}.stdout
} || {
    STDOUT=/dev/null
}
export SCRIPT SSH_DEBUG LOG STDOUT STDERR

[[ "$(id -u)" == 0 ]] || { echo "you must be root"; exit 1; }

# logging methods
log()
{
    # be transparent to return code
    local _rtn=${?}
    local _msg=
    local _log=

    case "${1}" in
        "-err") _msg="$(cat -)"; _log=${STDERR} ;;
        "-out") _msg="$(cat -)"; _log=${STDOUT} ;;
        *) _msg="${*}"; _log=${LOG} ;;
    esac

    while IFS= read line; do
        [[ "${line}" ]] && {
            echo "$(date) ${SCRIPT}: ${line}" >>${_log}
        }
    done < <(echo "${_msg}")

    return ${_rtn}
}

[[ $(which dig) ]] || {
    log "this program requires 'dig' to function. Please install it"
    echo "dig is required. please install it"
    exit 1
}


#-------------------------------------------------------------------------------
function _resolve2ip()
{
    local _dns_name=${1}
    local _dns_server=${2}
    dig ${_dns_server:+@${_dns_server}} +noadditional +noauthority +noquestion ${_dns_name} \
        | grep -v '^;.*$' | sed '/^$/d' | grep -v 'CNAME' | awk '{ print $5 }' | tail -n1
}

#-------------------------------------------------------------------------------
function _get_configured_nameserver()
{
    dig localhost | grep SERVER | awk -F\( '{ print $2 }' | tr -d ')'
}

#-------------------------------------------------------------------------------
# handle ip changes in public dns
function _iterate_nameservers()
{

    [[ "${HOME_ADDR}" =~ [[:alpha:]] ]] && {

        # we're using a dns name
        # we'll query a bunch of public dns servers to see if the remote ip has changed.
        # this can help as the record propagates after changing the ip.
        local -a nameservers=( $(_get_configured_nameserver) ${PUBLIC_DNS_SERVERS[@]} )
        RESOLVED_IPS=()
        for (( n=0; n < ${#nameservers[@]}; n++ )); do
            RESOLVED_IPS+=( $(_resolve2ip ${HOME_ADDR} ${nameservers[${n}]}) )
        done

        RESOLVED_IPS=( $(echo "${RESOLVED_IPS[@]}" | uniq) )

    } || {

        # here we just have an ip configured instead of a dns name.
        # if it changes on us, we're basically out of luck.
        RESOLVED_IPS=( ${HOME_ADDR} )

    }

    [[ ${#RESOLVED_IPS[@]} -gt 0 ]] || {
    log "unable to connect to '${HOME_ADDR}'"
    exit 1
    }

}

#-------------------------------------------------------------------------------
# test remote connectivity
_iterate_nameservers

unset RESOLVED_IP
for (( ip=0; ip < ${#RESOLVED_IPS[@]}; ip++ )); do

    conn=$(ssh ${SSH_DEBUG} root@${RESOLVED_IPS[${i}]} "ls / | grep usr" 2> >(log -err) | tee >(log -out))

    [[ ${?} -eq 0 && "${conn}" =~ usr ]] && {
        RESOLVED_IP=${RESOLVED_IPS[${i}]}
        export RESOLVED_IP
        ip=${#RESOLVED_IPS[@]}
    }

done

[[ ${RESOLVED_IP} ]] || {
    log "unable to connect to '${HOME_ADDR}'"
    exit 1
}

#-------------------------------------------------------------------------------
# see if the tunnel looks up
tries=1 conn=
until [[ ${conn} ]] || [[ ${tries} -gt ${MAXTRIES} ]]; do

    conn="$(ssh ${SSH_DEBUG} -o 'StrictHostKeyChecking no' ${RESOLVED_IP} "netstat -ln --inet|grep '[[:blank:]]127\.0\.0\.1:${PORT}[[:blank:]].*LISTEN[[:blank:]]*$'" 2> >(log -err) | tee >(log -out))"

    [[ ${conn} ]] && {

        # see if we can double back. your home's root keys need to be in work's /root/.ssh/authorized_keys
        [[ "$(ssh ${SSH_DEBUG} -o 'StrictHostKeyChecking no' ${RESOLVED_IP} "ssh ${SSH_DEBUG} -p${PORT} localhost 'ls / | grep usr'" 2> >(log -err) | tee >(log -out))" =~ usr ]] && {

            log '__MARK__'

        } || {

            # if not, kill the tunnel client-outide, and we'll restart it
            ssh ${SSH_DEBUG} -o 'StrictHostKeyChecking no' ${RESOLVED_IP} \
                "conn_pid=\$(netstat -lnpa --inet | grep '127\.0\.0\.1:${PORT}' | grep sshd | awk '{ print \$7 }' | awk -F/ '{ print \$1 }' | uniq); [[ \${conn_pid} ]] && kill \$(echo -n "\${conn_pid}")" 2> >(log -err) | tee >(log -out)
            tries=$((${MAXTRIES} + 1))
        }

    } || {

        log "Attempt [${tries}] at verifying the reverse tunnel connection to ${RESOLVED_IP} (${HOME_ADDR})..."
        tries=$((${tries} + 1))
        sleep 5
    }
done

#-------------------------------------------------------------------------------
# (re)establish reverse tunnel if needed
[[ ${tries} -gt ${MAXTRIES} ]] || [[ ! "${conn}" ]] && {
    # force kill the local endpoint if it exists
    conn_pid="$(ps axo pid,cmd | grep "localhost:${PORT}:localhost:22" | grep -v grep | awk '{ print $1 }')"
    [[ ${conn_pid} ]] && kill $(echo -n "${conn_pid}")

    log "reverse tunnel is down. restarting..."
    ssh ${SSH_DEBUG} -o 'StrictHostKeyChecking no' -fgNTR localhost:${PORT}:localhost:22 root@${RESOLVED_IP} 2> >(log -err) && {
        log "reverse tunnel to ${RESOLVED_IP} (${HOME_ADDR}) activated"
    } || {
        log "restarting reverse tunnel FAILED."
    }
}
#-------------------------------------------------------------------------------

:<<DOC
Overview:
 This script establishes and maintains an ssh reverse tunnel connection
 from one location to another.

Problem:
 Your work box sits behind a NAT router in the office, and you
 want/need to access it from home whenever you need to via ssh, scp or
 nx.

Solution:
 This script will generate a reverse ssh tunnel from work to home
 and make sure it stays up, re-establishing it whenever it drops.


Setup @ work
---------------------------------------------------------------------
 Make sure this script (revpipe) is executable.

 There are two configuration settings you MUST set in the revpipe
 script itself.

  youasroot@work emacs ~/bin/revpipe

 Set HOME_ADDR and PORT variables as appropriate.

  Here's a handy one-liner to run from a pc (e.g. your home desktop)
  to get your current external IP address:

  $ wget http://automation.whatismyip.com/n09230945.asp -O - -o /dev/null

  Save the line above to ~/bin/getip, and chmod it to 755.
  Then you can use 'getip' whenever you need to grab your ip.


 In order for your tunnel to work, you'll need to be able to ssh
 into your home pc as root, from work as root, as in:

  youasroot@work~# ssh root@your_house

 without a password, using ssh keys from work into your home pc.

 To get your keys setup:

  youasroot@work~# ssh-copy-id -i <pubkeyfile> root@your_house

 where <pubkeyfile> is typically either of:

  ~/.ssh/id_dsa.pub or ~/.ssh/id_rsa.pub

 Note:
 revpipe must be run as root on your work box, and should be run
 from root's crontab like so:

 # crontab example to restart tunnel
 MAILTO=''
 #m    h dom mon dow  command
 @reboot             /path/to/revpipe 2>&1 >/dev/null
 */5  *  *   *   *   /path/to/revpipe 2>&1 >/dev/null

  youasroot@work~# crontab -e

 Use above command to edit root's crontab.

 The crontab above  will check the connection on reboot, and
 every 5 minutes thereafter while your work box is running.
 If the test fails 5 times, it will recreate the tunnel.


Advanced Work-side Configuration Options
---------------------------------------------------------------------
 If you want to use a faster but less secure cipher, such as arcfour
 or blowfish, you'll need to setup a Host section in your
 ~/.ssh/config file. Create the file if it does not already exist.

 Example ~/.ssh/config Host section

   Host *.yourdomain.com
       Ciphers arcfour,arcfour128,arcfour256,blowfish-cbc
       BatchMode yes
       Compression yes

 Then, set HOST=work-home-tunnel in the configuration
 section of revpipe


Setup @ home
---------------------------------------------------------------------
 To get to your desktop at home, you'll need to configure your home
 router to forward incoming ssh (port 22) to your box inside, and
 make sure sshd is running on your box, and that you can ssh in as
 root. (/etc/ssh/sshd_config)

 PermitRootLogin yes

 It's a VERY good idea, AFTER you have keys working from work to
 DISABLE password authentication in /etc/ssh/sshd_config on your
 home desktop, as in:

 PasswordAuthentication no

 That way, login can only occur via keys, and that helps reduce
 your exposure from the internet. You can also adjust your
 firewall to limit access to only your Work's external ip address.


Using the Tunnel
---------------------------------------------------------------------
 With this script connected from work to your home pc, accessing your
 work pc from home is done by ssh-ing to localhost, on the configured
 port, as in:

  you@home$ ssh -p2222 workyou@localhost

 This will go back through the local reverse tunnel endpoint, which
 is at localhost:2222, dropping you right onto your work pc. Or, to
 copy files to your work desktop:

  you@home$ scp -P2222 /my/local/file workyou@localhost:~/Desktop/

 NX server, from nomachine (www.nomachine.com), works great to deliver
 a full graphical desktop experience over this reverse tunnel. To use
 it, setup nxserver on your work box, and use nxclient on your home
 machine. In the client configuration, set your target to be
 localhost, on the port you specified above. I'm writing this on my
 work desktop from home. It spans two monitors fullscreen, and it
 feels almost as fast as being there. Try it - it blows vnc away.


 Some other ssh settings to read up on:
  ServerAliveCountMax
  ServerAliveInterval

 Use 'apropos ssh' for a list of related ssh manpages. ssh_config is a
 good manpage to read.  If the tunnel is isolated by firewalls by IP
 addresses, you might consider a less robust tunnel cipher to improve
 performance, like possibly arcfour. Use root's ~/.ssh/config to
 modify the cipher for this connection only. See Advanced Work-side
 Configuration Options above for more information.

DOC
